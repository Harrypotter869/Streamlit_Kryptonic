{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "75e39fa1",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\Verona\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python312\\site-packages\\tqdm\\auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n",
      "  from .autonotebook import tqdm as notebook_tqdm\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Could not delete collection (might not exist): Collection [kryptonic_crypto_knowledge] does not exists\n",
      "Loaded 20 crypto entries into ChromaDB collection: 'kryptonic_crypto_knowledge'.\n",
      "Downloading NLTK resource: wordnet...\n",
      "Finished downloading wordnet.\n",
      "üí∞ Hello, I‚Äôm Kryptonic ‚Äì your smart assistant for cryptocurrency and blockchain!\n",
      "üìä Ask me about Bitcoin, Ethereum, DeFi, NFTs, blockchain concepts, crypto security, or general crypto investment principles.\n",
      "I cannot give personalized financial advice or price predictions. Always do your own research (DYOR) and understand the risks.\n",
      "Type 'exit' or 'bye' any time to end this session.\n",
      "\n",
      "Kryptonic: Gemini AI integration active for advanced queries with Temperature: 0.4 and Max Output Tokens: 1280.\n",
      "Kryptonic: Goodbye! Stay decentralized and secure! üöÄ Remember Kryptonic is always here for your crypto questions.\n"
     ]
    }
   ],
   "source": [
    "\n",
    "import re\n",
    "import os\n",
    "import nltk\n",
    "from nltk.corpus import stopwords\n",
    "from nltk.stem import WordNetLemmatizer\n",
    "import requests\n",
    "import pandas as pd\n",
    "import chromadb\n",
    "\n",
    "import google.generativeai as genai\n",
    "\n",
    "# --- ChromaDB Setup ---\n",
    "# Load the Crypto Currency.csv\n",
    "csv_filename = \"Crypto Currency.csv\"\n",
    "try:\n",
    "    df = pd.read_csv(csv_filename)\n",
    "except FileNotFoundError:\n",
    "    print(f\"Error: The file '{csv_filename}' was not found.\")\n",
    "    print(\"Please ensure 'Crypto Currency.csv' is in the same directory as the script.\")\n",
    "    exit() # Exit if the CSV is crucial and not found\n",
    "\n",
    "client = chromadb.Client()\n",
    "collection_name = \"kryptonic_crypto_knowledge\" # A distinct name for the collection\n",
    "\n",
    "# Prepare documents for ChromaDB\n",
    "# Assuming your CSV has 'question' and 'answer' columns\n",
    "# You can concatenate them to form a comprehensive document for search\n",
    "# Ensure both columns are treated as strings to avoid errors with non-string data\n",
    "documents = (df['question'].astype(str) + \" \" + df['answer'].astype(str)).tolist()\n",
    "ids = [str(i) for i in range(len(documents))]\n",
    "\n",
    "# Create/Get the ChromaDB collection\n",
    "try:\n",
    "    # Attempt to delete and recreate the collection to ensure fresh data\n",
    "    # This is useful during development to avoid old data issues.\n",
    "    # In production, you might want to use client.get_or_create_collection\n",
    "    # and only add new documents or update existing ones.\n",
    "    client.delete_collection(collection_name)\n",
    "    print(f\"Deleted existing collection '{collection_name}' (if any).\")\n",
    "except Exception as e:\n",
    "    print(f\"Could not delete collection (might not exist): {e}\")\n",
    "\n",
    "collection = client.create_collection(name=collection_name)\n",
    "collection.add(\n",
    "    documents=documents,\n",
    "    ids=ids\n",
    ")\n",
    "\n",
    "print(f\"Loaded {collection.count()} crypto entries into ChromaDB collection: '{collection_name}'.\")\n",
    "\n",
    "# --- Existing Kryptonic Functions (unchanged, copied from your provided code) ---\n",
    "\n",
    "def detect_top_coins_query(user_input):\n",
    "    keywords = [\"top coins\", \"top 5\", \"biggest crypto\", \"top crypto\", \"largest coins\"]\n",
    "    for key in keywords:\n",
    "        if key in user_input.lower():\n",
    "            return get_top_coins()\n",
    "    return None\n",
    "\n",
    "def get_top_coins(limit=5):\n",
    "    url = \"https://api.coingecko.com/api/v3/coins/markets\"\n",
    "    params = {\n",
    "        \"vs_currency\": \"usd\",\n",
    "        \"order\": \"market_cap_desc\",\n",
    "        \"per_page\": limit,\n",
    "        \"page\": 1,\n",
    "        \"sparkline\": False\n",
    "    }\n",
    "    try:\n",
    "        response = requests.get(url, params=params)\n",
    "        data = response.json()\n",
    "        output = [\"üìä Top Cryptocurrencies by Market Cap:\"]\n",
    "        for coin in data:\n",
    "            name = coin['name']\n",
    "            price = coin['current_price']\n",
    "            output.append(f\"‚Ä¢ {name}: ${price:,}\")\n",
    "        return \"\\n\".join(output)\n",
    "    except Exception as e:\n",
    "        return f\"‚ö†Ô∏è Failed to fetch top coins. Please try again later. Error: {e}\"\n",
    "\n",
    "def get_crypto_price(coin_id=\"bitcoin\"):\n",
    "    url = f\"https://api.coingecko.com/api/v3/simple/price\"\n",
    "    params = {\n",
    "        \"ids\": coin_id,\n",
    "        \"vs_currencies\": \"usd\",\n",
    "        \"include_24hr_change\": \"true\"\n",
    "    }\n",
    "    try:\n",
    "        response = requests.get(url, params=params)\n",
    "        data = response.json()\n",
    "        if coin_id in data:\n",
    "            price = data[coin_id]['usd']\n",
    "            change = data[coin_id]['usd_24h_change']\n",
    "            emoji = \"üìà\" if change > 0 else \"üìâ\"\n",
    "            return f\"üìä {coin_id.capitalize()}\\nüíµ Price: ${price:,.2f}\\n{emoji} 24h Change: {change:.2f}%\"\n",
    "        else:\n",
    "            return \"Coin not found. Try another one.\"\n",
    "    except Exception as e:\n",
    "        return f\"‚ö†Ô∏è Failed to fetch price for {coin_id}. Please try again later. Error: {e}\"\n",
    "\n",
    "# --- API Key Setup ---\n",
    "API_KEY = os.getenv(\"GEMINI_API_KEY\")\n",
    "if not API_KEY:\n",
    "    API_KEY = input(\"Enter your Gemini API key: \")\n",
    "    if not API_KEY:\n",
    "        raise ValueError(\"Gemini API key is required to proceed!\")\n",
    "genai.configure(api_key=API_KEY)\n",
    "\n",
    "# Set up NLTK data path\n",
    "NLTK_DATA_PATH = os.path.join(os.path.expanduser(\"~\"), \"nltk_data\")\n",
    "nltk.data.path.append(NLTK_DATA_PATH)\n",
    "\n",
    "# Download required NLTK resources safely\n",
    "def safe_nltk_download(resource):\n",
    "    try:\n",
    "        nltk.data.find(resource)\n",
    "    except LookupError:\n",
    "        print(f\"Downloading NLTK resource: {resource.split('/')[-1]}...\")\n",
    "        nltk.download(resource.split(\"/\")[-1], download_dir=NLTK_DATA_PATH, quiet=True)\n",
    "        print(f\"Finished downloading {resource.split('/')[-1]}.\")\n",
    "\n",
    "safe_nltk_download(\"tokenizers/punkt\")\n",
    "safe_nltk_download(\"corpora/stopwords\")\n",
    "safe_nltk_download(\"corpora/wordnet\")\n",
    "safe_nltk_download(\"taggers/averaged_perceptron_tagger\")\n",
    "\n",
    "stop_words = set(stopwords.words(\"english\"))\n",
    "lemmatizer = WordNetLemmatizer()\n",
    "\n",
    "def get_wordnet_pos(word):\n",
    "    tag = nltk.pos_tag([word])[0][1][0].upper()\n",
    "    tag_dict = {\"N\": \"n\", \"J\": \"a\", \"V\": \"v\", \"R\": \"r\"}\n",
    "    return tag_dict.get(tag, \"n\")\n",
    "\n",
    "def preprocess_input(text):\n",
    "    tokens = nltk.word_tokenize(text.lower())\n",
    "    filtered = [word for word in tokens if word.isalnum() and word not in stop_words]\n",
    "    lemmatized = [lemmatizer.lemmatize(word, get_wordnet_pos(word)) for word in filtered]\n",
    "    return ' '.join(lemmatized)\n",
    "\n",
    "# --- New function for querying ChromaDB ---\n",
    "def query_crypto_knowledge_base(question, kdb_collection, n_results=1, distance_threshold=0.5):\n",
    "    \"\"\"\n",
    "    Queries the ChromaDB collection for relevant information from the CSV.\n",
    "    Returns the best matching document if it meets the confidence (distance) threshold.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        results = kdb_collection.query(\n",
    "            query_texts=[question],\n",
    "            n_results=n_results,\n",
    "            include=['documents', 'distances'] # Ensure distances are included\n",
    "        )\n",
    "\n",
    "        if results and results['documents'] and results['documents'][0]:\n",
    "            best_match_doc = results['documents'][0][0]\n",
    "            best_match_distance = results['distances'][0][0]\n",
    "\n",
    "            # If the distance is below the threshold, consider it a good match.\n",
    "            # This threshold might need tuning based on your data and embedding model.\n",
    "            if best_match_distance < distance_threshold:\n",
    "                return best_match_doc\n",
    "            else:\n",
    "                return None # Match found but not confident enough\n",
    "        return None # No results found\n",
    "    except Exception as e:\n",
    "        print(f\"Kryptonic (ChromaDB Query Error): {e}\")\n",
    "        return None\n",
    "\n",
    "# --- Persona Definitions for Kryptonic ---\n",
    "crypto_personas = {\n",
    "    \"beginner\": {\n",
    "        \"name\": \"Crypto Beginner's Guide\",\n",
    "        \"template\": \"\"\"You are Kryptonic, a helpful and patient crypto expert guiding a beginner.\n",
    "Explain complex crypto concepts in simple, easy-to-understand terms, avoiding jargon where possible.\n",
    "Prioritize foundational knowledge and highlight key safety tips for new users.\n",
    "\n",
    "CRYPTO KNOWLEDGE:\n",
    "{context}\n",
    "\n",
    "USER QUESTION: {question}\n",
    "\n",
    "BEGINNER-FOCUSED RESPONSE STYLE:\n",
    "- Use clear, simple language.\n",
    "- Define any technical terms you use.\n",
    "- Focus on basic concepts and practical implications.\n",
    "- Emphasize security and \"Do Your Own Research\" (DYOR) for newcomers.\n",
    "- Be encouraging and reassuring.\n",
    "\n",
    "ANSWER:\"\"\"\n",
    "    },\n",
    "\n",
    "    \"technical\": {\n",
    "        \"name\": \"Blockchain Architect\",\n",
    "        \"template\": \"\"\"You are Kryptonic, a highly knowledgeable and detailed blockchain architect, passionate about the underlying technology.\n",
    "Provide comprehensive and technical explanations, delving into protocols, consensus mechanisms, and cryptographic principles.\n",
    "Assume the user has some technical understanding.\n",
    "\n",
    "CRYPTO KNOWLEDGE:\n",
    "{context}\n",
    "\n",
    "USER QUESTION: {question}\n",
    "\n",
    "TECHNICAL-FOCUSED RESPONSE STYLE:\n",
    "- Use accurate technical terminology.\n",
    "- Explain the \"how\" and \"why\" behind blockchain concepts.\n",
    "- Refer to specific protocols, algorithms, or standards where relevant.\n",
    "- Be precise and thorough in your explanations.\n",
    "\n",
    "ANSWER:\"\"\"\n",
    "    },\n",
    "\n",
    "    \"investor\": {\n",
    "        \"name\": \"Market Analyst & Investor Strategist\",\n",
    "        \"template\": \"\"\"You are Kryptonic, a sharp and analytical crypto market analyst, providing insights for investors and traders.\n",
    "Focus on market dynamics, investment principles, risk management strategies, and the factors influencing crypto asset values.\n",
    "Always disclaim that you do not provide financial advice and emphasize DYOR and market volatility.\n",
    "\n",
    "CRYPTO KNOWLEDGE:\n",
    "{context}\n",
    "\n",
    "USER QUESTION: {question}\n",
    "\n",
    "INVESTOR-FOCUSED RESPONSE STYLE:\n",
    "- Discuss market trends and economic factors.\n",
    "- Mention concepts like market capitalization, liquidity, and trading volumes.\n",
    "- Provide general strategies for risk management (e.g., diversification, dollar-cost averaging).\n",
    "- Avoid specific price predictions or buy/sell signals.\n",
    "- Always include a disclaimer about the risks of crypto investing.\n",
    "\n",
    "ANSWER:\"\"\"\n",
    "    },\n",
    "\n",
    "    \"security\": {\n",
    "        \"name\": \"Digital Asset Security Expert\",\n",
    "        \"template\": \"\"\"You are Kryptonic, a vigilant and practical digital asset security expert.\n",
    "Your primary focus is on guiding users through best practices for securing their cryptocurrencies and protecting against scams and vulnerabilities.\n",
    "\n",
    "CRYPTO KNOWLEDGE:\n",
    "{context}\n",
    "\n",
    "USER QUESTION: {question}\n",
    "\n",
    "SECURITY-FOCUSED RESPONSE STYLE:\n",
    "- Emphasize practical security measures (2FA, cold storage, strong passwords).\n",
    "- Warn about common scams (phishing, rug pulls, fake giveaways).\n",
    "- Provide actionable advice for protecting funds.\n",
    "- Be firm and clear about security risks and prevention.\n",
    "\n",
    "ANSWER:\"\"\"\n",
    "    },\n",
    "\n",
    "    \"general\": {\n",
    "        \"name\": \"General Crypto Assistant\",\n",
    "        \"template\": \"\"\"You are Kryptonic, a helpful and friendly general crypto assistant providing balanced information for all users.\n",
    "Offer clear and concise answers on various crypto topics without focusing on a specific angle.\n",
    "\n",
    "CRYPTO KNOWLEDGE:\n",
    "{context}\n",
    "\n",
    "USER QUESTION: {question}\n",
    "\n",
    "GENERAL RESPONSE STYLE:\n",
    "- Provide balanced, comprehensive information.\n",
    "- Be helpful and informative without being too specific to one user type.\n",
    "- Give a good overview with practical details.\n",
    "- Be warm and welcoming.\n",
    "\n",
    "ANSWER:\"\"\"\n",
    "    }\n",
    "}\n",
    "\n",
    "# --- Persona Detection Logic ---\n",
    "def detect_crypto_persona(question):\n",
    "    \"\"\"Analyze the question to determine which crypto persona to use.\"\"\"\n",
    "    question_lower = question.lower()\n",
    "\n",
    "    beginner_keywords = [\n",
    "        'what is', 'explain', 'simple', 'basics', 'newbie', 'first time', 'beginner',\n",
    "        'how to start', 'easy', 'understand', 'explain to me'\n",
    "    ]\n",
    "    technical_keywords = [\n",
    "        'protocol', 'algorithm', 'consensus', 'mechanism', 'smart contract',\n",
    "        'decentralized', 'hash', 'node', 'proof-of-work', 'proof-of-stake',\n",
    "        'layer 1', 'layer 2', 'interoperability', 'sharding', 'fork', 'mainnet'\n",
    "    ]\n",
    "    investor_keywords = [\n",
    "        'invest', 'investment', 'trade', 'market', 'price', 'value', 'portfolio',\n",
    "        'risk', 'return', 'profit', 'loss', 'bear market', 'bull market',\n",
    "        'diversify', 'strategy', 'hodl', 'liquid', 'yield', 'apy', 'market cap'\n",
    "    ]\n",
    "    security_keywords = [\n",
    "        'secure', 'security', 'scam', 'hack', 'wallet', 'private key', 'seed phrase',\n",
    "        '2fa', 'phishing', 'cold storage', 'hot wallet', 'safety', 'protect'\n",
    "    ]\n",
    "\n",
    "    beginner_score = sum(1 for keyword in beginner_keywords if keyword in question_lower)\n",
    "    technical_score = sum(1 for keyword in technical_keywords if keyword in question_lower)\n",
    "    investor_score = sum(1 for keyword in investor_keywords if keyword in question_lower)\n",
    "    security_score = sum(1 for keyword in security_keywords if keyword in question_lower)\n",
    "\n",
    "    scores = {\n",
    "        'beginner': beginner_score,\n",
    "        'technical': technical_score,\n",
    "        'investor': investor_score,\n",
    "        'security': security_score\n",
    "    }\n",
    "\n",
    "    best_persona = max(scores.items(), key=lambda x: x[1])\n",
    "\n",
    "    if best_persona[1] == 0:\n",
    "        return 'general'\n",
    "\n",
    "    return best_persona[0]\n",
    "\n",
    "# --- Main Chatbot Function with Personas ---\n",
    "def Kryptonic_chatbot():\n",
    "    \"\"\"Kryptonic: A hybrid chatbot for cryptocurrency education and responsible financial guidance with personas.\"\"\"\n",
    "    print(\"üí∞ Hello, I‚Äôm Kryptonic ‚Äì your smart assistant for cryptocurrency and blockchain!\")\n",
    "    print(\"üìä Ask me about Bitcoin, Ethereum, DeFi, NFTs, blockchain concepts, crypto security, or general crypto investment principles.\")\n",
    "    print(\"I cannot give personalized financial advice or price predictions. Always do your own research (DYOR) and understand the risks.\")\n",
    "    print(\"Type 'exit' or 'bye' any time to end this session.\\n\")\n",
    "\n",
    "    # --- Gemini Model Initialization ---\n",
    "    gemini_model = None\n",
    "    gemini_chat = None\n",
    "    try:\n",
    "        # Define generation configuration for the model\n",
    "        # These settings apply to all responses from this model instance\n",
    "        generation_config = {\n",
    "            \"temperature\": 0.4,  # Controls randomness. 0.0 for deterministic, 1.0 for creative.\n",
    "            \"max_output_tokens\": 1280, # Max tokens in a single response.\n",
    "        }\n",
    "\n",
    "        # Initialize the GenerativeModel with the chosen model and generation configuration\n",
    "        gemini_model = genai.GenerativeModel(\"gemini-1.5-flash-latest\", generation_config=generation_config)\n",
    "\n",
    "        # The initial chat history sets a general base persona for Kryptonic.\n",
    "        # Specific personas are applied dynamically via the prompt template later.\n",
    "        gemini_chat = gemini_model.start_chat(history=[\n",
    "            {\"role\": \"user\", \"parts\": [\n",
    "                \"You are Kryptonic, a highly knowledgeable and enthusiastic AI assistant specializing exclusively in cryptocurrency, blockchain technology, and digital assets. \"\n",
    "                \"Your purpose is to provide clear, accurate, and educational information about crypto concepts, market trends, security best practices, and general investment principles specific to crypto (e.g., diversification, risk management, cold storage, project analysis). \"\n",
    "                \"Crucially, you do not provide personalized financial advice, specific buy/sell recommendations, or price predictions. Always emphasize 'Do Your Own Research' (DYOR) and the inherent volatility and risks of crypto. \"\n",
    "                \"Always focus your responses strictly on crypto-related topics. If a query is outside of cryptocurrency, politely state that your expertise is limited to crypto and offer to help with a crypto-related question instead. \"\n",
    "                \"When appropriate, or if a user asks for more information/resources, recommend reputable general sources for further research. \"\n",
    "                \"Prioritize safety and responsible crypto practices in your guidance.\"\n",
    "            ]},\n",
    "            {\"role\": \"model\", \"parts\": [\"Understood. I'm ready to dive into the world of crypto. How can I assist you in your decentralized journey?\"]}\n",
    "        ])\n",
    "\n",
    "        print(f\"Kryptonic: Gemini AI integration active for advanced queries with Temperature: {generation_config['temperature']} and Max Output Tokens: {generation_config['max_output_tokens']}.\")\n",
    "    except Exception as e:\n",
    "        print(f\"Kryptonic: ‚ö†Ô∏è Error initializing Gemini AI: {e}\")\n",
    "        print(\"Kryptonic: I will operate using only my predefined rules.\")\n",
    "\n",
    "    # --- Main Chat Loop ---\n",
    "    while True:\n",
    "        user_input = input(\"You: \").strip(\" !?.\")\n",
    "        lower_input = user_input.lower()\n",
    "\n",
    "        if lower_input in ['exit', 'bye', 'quit', 'see you']:\n",
    "            print(\"Kryptonic: Goodbye! Stay decentralized and secure! üöÄ Remember Kryptonic is always here for your crypto questions.\")\n",
    "            return  # End session\n",
    "\n",
    "        matched_by_response_system = False\n",
    "\n",
    "        # 1. API-based queries (Top Coins, Price Lookup) - These remain high priority\n",
    "        top_coins_response = detect_top_coins_query(user_input)\n",
    "        if top_coins_response:\n",
    "            print(\"Kryptonic:\", top_coins_response)\n",
    "            matched_by_response_system = True\n",
    "        elif re.search(r\"\\bwhat is the price of (\\w+)\\b\", lower_input):\n",
    "            coin_match = re.search(r\"\\bwhat is the price of (\\w+)\\b\", lower_input)\n",
    "            coin_id = coin_match.group(1).lower()\n",
    "            print(\"Kryptonic:\", get_crypto_price(coin_id))\n",
    "            matched_by_response_system = True\n",
    "\n",
    "        # 2. Persona-driven and RAG/Gemini Fallback\n",
    "        if not matched_by_response_system:\n",
    "            # Detect the persona\n",
    "            detected_persona_key = detect_crypto_persona(user_input)\n",
    "            persona_info = crypto_personas[detected_persona_key]\n",
    "            print(f\"Kryptonic (Persona Detected): Using '{persona_info['name']}' style.\")\n",
    "\n",
    "            # Search ChromaDB for relevant information (RAG)\n",
    "            relevant_info = query_crypto_knowledge_base(user_input, collection)\n",
    "            \n",
    "            context_for_gemini = relevant_info if relevant_info else \"No specific knowledge found in the database. Rely on general crypto knowledge.\"\n",
    "\n",
    "            if gemini_chat:\n",
    "                try:\n",
    "                    # Construct the prompt using the detected persona's template\n",
    "                    prompt = persona_info['template'].format(\n",
    "                        context=context_for_gemini,\n",
    "                        question=user_input\n",
    "                    )\n",
    "                    \n",
    "                    print(\"Kryptonic: \", end=\"\", flush=True)\n",
    "                    gemini_response = gemini_chat.send_message(prompt, stream=True)\n",
    "                    for chunk in gemini_response:\n",
    "                        print(chunk.text, end=\"\", flush=True)\n",
    "                    print()\n",
    "                    matched_by_response_system = True # Gemini responded\n",
    "                except Exception as e:\n",
    "                    print(f\"\\nKryptonic: ‚ö†Ô∏è Sorry, I had trouble connecting to my knowledge source or generating a response.\")\n",
    "                    print(f\"Kryptonic: (Error: {e})\")\n",
    "                    print(\"Kryptonic: My apologies, I'm designed to assist with cryptocurrency and blockchain questions only. Can I help you understand Bitcoin, NFTs, or decentralized finance instead? Remember to DYOR!\")\n",
    "                    matched_by_response_system = True # Tried to respond, but failed\n",
    "\n",
    "        # Fallback if no specific system handled the query (should be rare with Gemini)\n",
    "        if not matched_by_response_system:\n",
    "            print(\"Kryptonic: My apologies, I'm designed to assist with cryptocurrency and blockchain questions only. Can I help you understand Bitcoin, NFTs, or decentralized finance instead? Remember to DYOR!\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    Kryptonic_chatbot()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
